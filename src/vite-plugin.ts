import { createHash } from 'node:crypto'
import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync } from 'node:fs'
import { basename, resolve } from 'node:path'

import type { Plugin } from 'vite'

const hash = (s: string) => createHash('sha256').update(s).digest('hex')

// cache to avoid unnecessary writes
let generateCache: Record<string, string> = {}

function writeFileIfChanged(filePath: string, content: string): boolean {
  const contentHash = hash(content)
  if (generateCache[filePath] === contentHash && existsSync(filePath)) {
    return false
  }
  writeFileSync(filePath, content, 'utf-8')
  generateCache[filePath] = contentHash
  return true
}

function generateModelsFile(modelFiles: string[]) {
  const modelNames = modelFiles.map((f) => basename(f, '.ts')).sort()
  const getImportName = (name: string) => (name === 'user' ? 'userPublic' : name)

  const imports = modelNames
    .map((name) => `import * as ${getImportName(name)} from '../models/${name}'`)
    .join('\n')

  const sortedByImportName = [...modelNames].sort((a, b) =>
    getImportName(a).localeCompare(getImportName(b))
  )
  const modelsObj = `export const models = {\n${sortedByImportName.map((name) => `  ${getImportName(name)},`).join('\n')}\n}`

  const hmrBoundary = `
if (import.meta.hot) {
  import.meta.hot.accept()
}
`

  return `// auto-generated by on-zero vite plugin\n${imports}\n\n${modelsObj}\n${hmrBoundary}`
}

function generateTypesFile(modelFiles: string[]) {
  const modelNames = modelFiles.map((f) => basename(f, '.ts')).sort()
  const getSchemaName = (name: string) => (name === 'user' ? 'userPublic' : name)

  const typeExports = modelNames
    .map((name) => {
      const pascalName = name.charAt(0).toUpperCase() + name.slice(1)
      const schemaName = getSchemaName(name)
      return `export type ${pascalName} = TableInsertRow<typeof schema.${schemaName}>\nexport type ${pascalName}Update = TableUpdateRow<typeof schema.${schemaName}>`
    })
    .join('\n\n')

  return `import type { TableInsertRow, TableUpdateRow } from 'on-zero'\nimport type * as schema from './tables'\n\n${typeExports}\n`
}

function generateTablesFile(modelFiles: string[]) {
  const modelNames = modelFiles.map((f) => basename(f, '.ts')).sort()
  const getExportName = (name: string) => (name === 'user' ? 'userPublic' : name)

  const exports = modelNames
    .map((name) => `export { schema as ${getExportName(name)} } from '../models/${name}'`)
    .join('\n')

  return `// auto-generated by on-zero vite plugin\n\n${exports}\n`
}

async function runGenerate(options: {
  modelsDir: string
  generatedDir: string
  silent?: boolean
}) {
  const { modelsDir, generatedDir, silent } = options

  if (!existsSync(generatedDir)) {
    mkdirSync(generatedDir, { recursive: true })
  }

  const allModelFiles = readdirSync(modelsDir)
    .filter((f) => f.endsWith('.ts'))
    .sort()

  const filesWithSchema = allModelFiles.filter((f) =>
    readFileSync(resolve(modelsDir, f), 'utf-8').includes('export const schema = table(')
  )

  const writeResults = [
    writeFileIfChanged(
      resolve(generatedDir, 'models.ts'),
      generateModelsFile(allModelFiles)
    ),
    writeFileIfChanged(
      resolve(generatedDir, 'types.ts'),
      generateTypesFile(filesWithSchema)
    ),
    writeFileIfChanged(
      resolve(generatedDir, 'tables.ts'),
      generateTablesFile(filesWithSchema)
    ),
  ]

  const filesChanged = writeResults.filter(Boolean).length
  if (filesChanged > 0 && !silent) {
    console.info(`[on-zero] generated ${filesChanged} file(s)`)
  }

  return filesChanged
}

export interface OnZeroPluginOptions {
  /**
   * Path to data directory containing models/ and generated/
   * @default 'src/data'
   */
  dataDir?: string

  /**
   * Additional paths to apply HMR fix to
   */
  hmrInclude?: string[]

  /**
   * Disable code generation (HMR only)
   */
  disableGenerate?: boolean
}

/**
 * Vite plugin for on-zero that handles:
 * 1. Code generation (models.ts, types.ts, tables.ts)
 * 2. HMR support for model files (prevents cascade, enables hot-swap)
 *
 * @example
 * ```ts
 * import { onZeroPlugin } from 'on-zero/vite'
 *
 * export default {
 *   plugins: [
 *     onZeroPlugin(),
 *     // ... other plugins
 *   ]
 * }
 * ```
 */
export function onZeroPlugin(options: OnZeroPluginOptions = {}): Plugin[] {
  const dataDir = options.dataDir || 'src/data'
  const hmrPaths = ['/models/', '/generated/', ...(options.hmrInclude || [])]

  let modelsDir: string
  let generatedDir: string

  return [
    // generation plugin
    {
      name: 'on-zero:generate',
      apply: 'serve',

      configResolved(config) {
        modelsDir = resolve(config.root, dataDir, 'models')
        generatedDir = resolve(config.root, dataDir, 'generated')
      },

      async buildStart() {
        if (options.disableGenerate) return
        await runGenerate({ modelsDir, generatedDir, silent: false })
      },

      configureServer(server) {
        if (options.disableGenerate) return

        // watch for model changes
        server.watcher.on('change', async (file) => {
          if (file.includes(modelsDir)) {
            await runGenerate({ modelsDir, generatedDir, silent: false })
          }
        })

        server.watcher.on('add', async (file) => {
          if (file.includes(modelsDir)) {
            await runGenerate({ modelsDir, generatedDir, silent: false })
          }
        })

        server.watcher.on('unlink', async (file) => {
          if (file.includes(modelsDir)) {
            await runGenerate({ modelsDir, generatedDir, silent: false })
          }
        })
      },
    },

    // HMR plugin - removes invalidate calls to prevent cascade
    {
      name: 'on-zero:hmr',
      apply: 'serve',
      enforce: 'post',

      transform(code, id) {
        const shouldTransform = hmrPaths.some((p) => id.includes(p)) && /\.tsx?$/.test(id)

        if (shouldTransform && code.includes('import.meta.hot.invalidate')) {
          return {
            code: code.replace(
              /if\s*\(invalidateMessage\)\s*import\.meta\.hot\.invalidate\(invalidateMessage\);?/g,
              '/* on-zero: HMR invalidate disabled */'
            ),
            map: null,
          }
        }
      },
    },

    // build plugin - generate once before build
    {
      name: 'on-zero:build',
      apply: 'build',

      configResolved(config) {
        modelsDir = resolve(config.root, dataDir, 'models')
        generatedDir = resolve(config.root, dataDir, 'generated')
      },

      async buildStart() {
        if (options.disableGenerate) return
        await runGenerate({ modelsDir, generatedDir, silent: true })
      },
    },
  ]
}

// legacy export for backwards compat
export const onZeroHmrPlugin = (options?: { include?: string[] }): Plugin => {
  return onZeroPlugin({ hmrInclude: options?.include, disableGenerate: true })[1]
}

export default onZeroPlugin
